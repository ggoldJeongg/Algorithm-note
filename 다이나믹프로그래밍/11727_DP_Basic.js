// 문제 설명 : 2×n 타일링 문제. 2×n 크기의 직사각형을 2×1과 2×2 타일로 채우는 방법의 수를 구하기
// 핵심 개념 : 다이나믹 프로그래밍, 모듈러 연산

// (1) 기본 규칙 설정
let fs = require("fs");
let data = fs.readFileSync("/dev/stdin").toString().trim();
let n = Number(data);

function tiling(n) {
  const MOD = 10007; // 결과 값을 10007로 나눈 나머지를 구하기 위해 MOD 변수 설정
  let dp = Array(n + 1).fill(0); // dp 배열을 n+1 크기로 초기화, 각 인덱스는 해당 길이의 타일링 경우의 수를 저장

  dp[1] = 1; // 길이 1인 경우 타일링 방법은 1가지 (2x1 타일 하나)
  if (n >= 2) dp[2] = 3; // 길이 2인 경우 타일링 방법은 3가지 (2x1 타일 2개, 2x2 타일 1개, 2x1 타일 2개 가로로)

  // 다이나믹 프로그래밍으로 dp 배열 채우기 : 반복으로 큰 문제 해결하기
  for (let i = 3; i <= n; i++) {
    // dp[i-1]은 마지막에 2x1 타일 하나를 추가하는 경우
    // dp[i-2]는 마지막에 2x2 타일 하나를 추가하는 경우와 2x1 타일 두개를 세로로 추가하는 경우(2배)
    dp[i] = (dp[i - 1] + 2 * dp[i - 2]) % MOD;
  }

  return dp[n]; // n길이의 타일링 경우의 수 반환
}

console.log(tiling(n));

// 시간복잡도 : O(n) - dp 배열을 채우기 위해 n번 순회하면서, n에 선형적으로 비례

// dp 알고리즘 : 큰 문제를 작은 부분 문제로 나누고, 작은 부분 문제의 해를 이용해 전체 문제를 해결
// 큰 문제 : 2×n 크기의 직사각형을 타일링하는 방법의 수
// 작은 문제 : 2×1, 2×2, 2×3 등 소수 길이의 직사각형을 타일링하는 방법의 수

// 자료구조 : 배열을 선택하여 각 길이에 대한 타일링 경우의 수를 저장
// MOD 연산을 통해 값이 너무 커지는 것을 방지
