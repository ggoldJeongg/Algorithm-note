// 문제 설명 : 돌게임에서 N이 주어졌을 때, SK(상근)과 CY(창영) 중 누가 이길지 결정하기
// 핵심 개념 : 다이나믹 프로그래밍, 기본 규칙 찾기

// (1) 기본 규칙 찾기
let fs = require("fs");
let data = fs.readFileSync("/dev/stdin").toString().split("\n");

let N = Number(data[0]);

function stoneGame(N) {
  return N % 2 === 0 ? "CY" : "SK";
}
//N이 1 또는 3이면 상근이가 승리
// N이 2 또는 4이면 창영이가 승리
// 그 이후에는 5부터 4씩 증가할 때마다 승자가 번갈아 바뀐다.
// => N이 홀수이면 상근이가 승리하고, N이 짝수이면 창영이가 승리

console.log(stoneGame(N));

// 시간복잡도 : O(1) : 홀짝 판별은 상수시간 소요

// (2) 다이나믹 프로그래밍
function stoneGame(N) {
  // dp 배열을 N + 1 크기로 초기화
  // dp[i]는 돌이 i개 있을 때 해당 상태에서 이길 수 있는 플레이어
  const dp = Array(N + 1).fill(false);

  // 초기 상태 설정 (기본 규칙 설정, 작은 부분의 문제 해 구하기)
  dp[1] = true; // 돌이 1개 있을 때는 SK가 승리
  if (N >= 2) dp[2] = false; // 돌이 2개 있을 때는 CY가 승리
  if (N >= 3) dp[3] = true; // 돌이 3개 있을 때는 SK가 승리

  // 다이나믹 프로그래밍으로 dp 배열 채우기 : 반복으로 큰 문제 해결하기
  for (let i = 4; i <= N; i++) {
    // 돌이 i개 있을 때, 돌을 1개 또는 3개 빼는 경우를 고려
    // 상대방이 이길 수 없는 상태(!dp[i-1] 또는 !dp[i-3])인 경우, 현재 상태에서 SK가 승리
    if (!dp[i - 1] || !dp[i - 3]) {
      dp[i] = true;
    } else {
      dp[i] = false;
    }
  }

  // N개의 돌이 있을 때 SK가 이길 수 있으면 "SK"를 , 그렇지 않으면 "CY"를 반환
  return dp[N] ? "SK" : "CY";
}
console.log(stoneGame(N));

// dp 알고리즘 : 큰 문제를 작은 부분 문제로 나누고, 작은 부분 문제의 해를 이용해 전체 문제를 해결
//큰 문제 : 돌이 N개 있을 때 누가 이길지를 결정하기
//작은 문제 : 돌의 개수가 1개, 2개, 3개 등 소수일 때 누가 이길지를 결정하기

//자료구조 : 배열을 선택하여 돌의 개수에 대응하여 인덱스 매칭
//시간복잡도 : O(N) - dp 배열의 반복문이 N번 순회하면서, N에 선형적으로 비례
